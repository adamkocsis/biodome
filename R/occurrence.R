# Functions that simulate full occurrence distribution results

#' Uniform Bernoulli Model
#'
#' @param p Either a single probability value, or a vector of probabilities.
#' @param s Single integer, the number of taxa - only if p is a single probability value.
#' @param g A trigrid object defined in icosa
#' @param k The number of spatial cells.
#' @export
#' @examples
#'
#' # Single probabilitty, repeated s number of times
#' repeated <- uniformOcc(p=0.3, s=100, k=40)
uniformOcc <- function(p, s=NULL, g=NULL, k=NULL, nozero=TRUE){
	# an icosa grid is given
	if(is.null(k) & !is.null(g)){
		k<- length(g)
	}
	if(is.null(k) & is.null(g)) stop("Either 'g' or 'k' is required.")

	if(any(is.na(p))) stop("None of the arguments can include missing values.")

	# p has to be valid probability values
	if(any(p <0) | any(p>1)) stop("The argument 'p' can only include valid probability values.")


	# defend against the wrong p and s combinations
	if(!is.null(s)){
		if(length(p)> 1) stop("Provide either a single 'p' and 's', or a vector of probabilities for 'p'.")
		if(length(s) >1  | any(is.na(s))) stop("The argument 's' has to be a positive integer.")
	}else{
		s <- length(p)
	}

	# a single uniform random variable
	rand <- runif(k*s, 0,1) # will be transformed later

	# completely uniform
	randomMatrix <- matrix(rand, ncol=s, nrow=k)

	# I. if a single probability is given
	# very simple case - everything is based on the same probability
	if(length(p)==1 & !is.null(s)){

		# defend s - has to be a positive integer)
		if(s < 1 | (s%%1!=0) ) stop("The argument 's' has to be a positive integer.")
		if(nozero) message("Zero occupancy is possible!")

		# if this is lower then the probabiliy, that indicates occurrence
		occurrenceMatrix <- randomMatrix <= p

	}else{

		# create an empty matrix
		occurrenceMatrix <- matrix(NA, ncol=s, nrow=k)

		if(nozero){
			# for every taxon
			for(i in 1:length(p)){
				# the presences of the taxon
				thisTaxon <- randomMatrix[,i] <= p[i]

				# store
				occurrenceMatrix[,i] <- thisTaxon

				# if the occupancy of the focal taxon is 0
				if(!any(thisTaxon)){
					# assign a single presence to the cell where likelyhood is the highest!
					occurrenceMatrix[which.max(randomMatrix[,i]),i] <- TRUE
				}

			}
		}else{
			# for every taxon
			for(i in 1:length(p)){
				occurrenceMatrix[,i] <- randomMatrix[,i] <= p[i]
			}

		}

	}

	# ensure correct naming
	occurrenceMatrix <- NameOccMat(occurrenceMatrix, g=g, p=p)

	return(occurrenceMatrix)
}



#' Circular occurrence model
#'
#' @param p Target occupancy expressed as a proportion. Either a single value, or a vector.
#' @param s Single integer, the number of taxa - only if p is a single probability value.
#' @param g A trigrid object defined in icosa
#' @export
#' @examples
#'
#' # Single probabilitty, repeated s number of times
#' repeated <- uniformOcc(p=0.3, s=100, k=40)
circleOcc <- function(g, p, s=NULL, centers=NULL){
	# an icosa grid is given
	k<- length(g)

	if(any(is.na(p))) stop("None of the arguments can include missing values.")

	# p has to be valid probability values
	if(any(p <0) | any(p>1)) stop("The argument 'p' can only include valid probability values.")


	# defend against the wrong p and s combinations
	if(!is.null(s)){
		if(length(p)> 1) stop("Provide either a single 'p' and 's', or a vector of probabilities for 'p'.")
		if(length(s) >1  | any(is.na(s))) stop("The argument 's' has to be a positive integer.")
	}else{
		s <- length(p)
	}

	# If a single probability is given
	if(length(p)==1 & !is.null(s)) p <- rep(p, s)


	# distance matrix
	cents <- icosa::centers(hex)[sample(1:length(hex)),]
	dists <- icosa::arcdistmat(cents)
	rownames(dists) <- rownames(cents)
	colnames(dists) <- rownames(cents)

	# create an empty matrix
	occurrenceMatrix <- matrix(FALSE, ncol=s, nrow=k)
	rownames(occurrenceMatrix) <- icosa::faces(hex)

	# center of the occurrence
	if(is.null(centers)){
		# get the centers
		centers <- sample(icosa::faces(hex), s, replace=TRUE)
	}


	# for every taxon
	for(i in 1:length(p)){

		# focal part
		thisSub <- dists[, centers[i]]

		# select the first p*k
		occupied <- colnames(dists)[order(thisSub)[1:ceiling(p[i]*k)]]

		# insert presence
		occurrenceMatrix[occupied,i] <- TRUE
	}

	# ensure correct naming
	occurrenceMatrix <- NameOccMat(occurrenceMatrix, g=g, p=p)

	return(occurrenceMatrix)
}

# Function that ensures the correct naming of the occurence matrix
NameOccMat <- function(x, g=NULL, p=NULL){

	if(is.null(rownames(x))){
		# add attributes - from icosa, if there
		if(!is.null(g)){
			rownames(x) <- icosa::faces(g)
		# fabricate otherwise
		}else{
			rownames(x) <- paste0("C", 1:nrow(x))
		}

	}
	# should the taxon names be autogenerated
	genTax <- TRUE

	if(!is.null(p)){
		# set the taxon names
		if(!is.null(names(p))){
			colnames(x) <- names(p)
			genTax <- FALSE
		}
	}

	if(genTax) colnames(x) <- paste0("T", 1:ncol(x))

	return(x)

}
